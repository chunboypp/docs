### 1

mysql5.7之后 mysql_reset_connetion 重置连接资源，并不是断开重连
不建议使用查询缓存，因为存在频繁失效的问题。只要对表有一次更新，就会失效
可以设置参数 query_cache_type 为demand ，按需查询，
需要用到缓存的时候 select SQL_CACHE * from 表名

分析器，识别表名 列命 语法分析  
优化器 确定执行方案，索引 执行代价更小
执行器

慢查询中的row_examined 表示扫描的行数

### 2

io成本比较高,每次都写磁盘会很慢
WAL write ahead logging 先写日志，再写磁盘
redo innodb 先写redo log,适当的时候写入磁盘
redo log固定大小，建议配置4个文件，每个1g.循环写。checkpouit  < writepoint 之间是未落盘数据
 crsh-safe-数据库异常重启，数据不会丢失。从redo log找回数据

binlog 数据库server 特有

为什么两份日志：innodb 后来才有，redo 记录数据页修改了什么。binlog记录的是逻辑日志；redo是循环写，覆盖，binglog是追加写

update: 数据在内存 ，直接更新返回。不在 从磁盘加载到内存
	redolog 写入 prepare  binlog 写入 red log commit

### 3

redo log保证safe-crash 需要设置参数 innodb_flush_log_at_trx_commit 为1，表示每次写redo log都落盘
sync_binlog 设置为1 每次写binlog都落盘

事务：acid 原子 一致 隔离 持久

串行化，写会加写锁，读会加读锁

事务是如何实现的，读提交和可重复读通过视图实现
	读提交，在执行sql的时候创建视图
	可重复读，在事务开启的时候创建视图

transaction-isolation（设置隔离级别）的值设置READ-COMMITTED

每条更新语句都会记录一个回滚操作。通过回滚可以得到前一个状态的值
	不同时刻启动的事务，有不同的read view,同一条记录可能存在多个版本(MVVC)

长事务就意味着更多的版本 视图，更多的存储空间
事务启动：显示启动 begin transaction | set autocommit=0
set autocommit=1 每次事务自动开启提交事务，如果显式 开启事务。
begin transaction with chain 不用每次begin,系统自动begin 省去了begin动作，更简洁
查询长事务
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60;

### 4

hash索引 只支持等值查询，不支持范围查询
有序数据只适合静态存储引擎
二叉树 叶子节点左小右大，顺序排序
n叉树，少回盘，每次多多数据
非主键索引多一次回表
页分裂，页合并。索引字段越小，占用空间就越小，每次加载到内存的数据就越多
根据业务预估 SET_MAX_EXECUTION_TIME 控制每个语句的最长执行时间
测试阶段general_log 进行查看

