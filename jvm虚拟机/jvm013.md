# G1   Garbage First Collector

## 三色标记算法

- 并发标记的三色算法-它是描述追踪式回收器的一种有效的方法，利用它可以推演回收器的正确性

- 将对象分成三种类型：

  - 黑色：根对象，或者改对象与它的子对象都被扫描过（对象被标记了，且它的所有field也被标记完了）
  - 灰色：对象本身被扫描，但还没扫描完该对象中的子对象（它的field还没有被标记或标记完）
  - 白色：未被扫描完，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象（对象没有被标记到）

- 根对象呗设置为黑色，子对象被置为灰色。

  图

- 继续由灰色遍历，将已扫描了子对象的对象置为黑色

  图

- 遍历了所有的可达的对象后，所有科大的对象都变成了黑色。不可达的对象即为白色，需要被清理。

  图

- 但是如果在标记过程中，应用程序也在运行，那么对象的指针就有可能改变。这样的话，我们就会遇到一个问题：对象丢失的问题

- 当垃圾收集器扫描到下面的情况时：

  图

- 这个时候应用程序执行了以下操作：

  - A.c= c
  - B.c= null

- 这样，对象的状态图变成了如下情形：

  图

- 这时候垃圾收集器在标记扫描的时候就会变成下图这样

  图

- 很显然，此时C是白色，被认为是垃圾需要清理掉，显然这是不合理的

## SATB

- 在G1中，使用的STAB（Snapshot-At-The-Beginning）的方式，删除的时候记录所有的对象
- 它有三个步骤
  - 在开始标记的时候生成一个快照图，标记存活的对象
  - 在并发标记的时候所有被改动的对象入队（在write barrier里吧所有旧的引用所指向的对象都变成非白的）
  - 可能存在浮动垃圾，将在下次被收集
- G1到现在可以知道哪些老的分区可以回收垃圾最多。当迁居并发标记完成后，在某个时刻，就开始了Mixed GC.这些垃圾回收被称作“混合式”是因为它们不仅仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的分区
- 混合式GC也是采用的复制清理策略，当GC完成后，会从新释放空间
- 为老年代设置分区的目的是老年代里有的分区垃圾多，有的分区垃圾少，这样在回收的时候可以专注于收集垃圾妒忌的分区，这也是G1名称的由来。
- 不过这个算法并不适合新生代垃圾收集，因为新生代的垃圾收集算法是复制算法，但是新生代也使用了分区机制主要是因为便于代大小的调整

## SATB详解

- SATB是维持并发GC的一种手段。G1并发的基础就是SATB.SATB可以理解成在GC开始之前对堆内存的对象做一个快照，此时活的对象就认为是获得，从而形成一个对象图。
- 在GC收集的时候，新生代的对象也认为是或的对象，除此之外其它不可达的对象都认为是垃圾对象
- 如何找到在GC过程中分配的对象呢？每个region记录着两个top-at-mark-start(TAMS)指针，分别为prevTAMS和nextTAMS.在TAMS以上的对象就是新分配的，因而被视为隐式的marked.
- 通过这种方式我们就找到了在GC过程中新分配的对象，并把这些对象认为是活的对象
- 对于GC过程呢中引用发生变化的问题，G1给出的解决办法是通过Write Barrier.Write Barrier就是对引用字段进行赋值做了额外处理。通过Write Barrier就可以了解到哪些引用对象发生了什么样的变化
- mark的过程就是遍历heap标记live object的过程，采用的是三色标记算法，这三种颜色为white（表示还未被访问到）、grap(访问到但是它用到的引用还没有完全扫描)、black(访问到而且启用到的引用已经完全扫描完)
- 整个三色标记算法就是从GC roots出发遍历heap,针对可达对象先标记white为gray,然后再标记gray为black;遍历完成之后所有可达对象都是black的，所有white都是可以回收的
- SATB仅仅对于在marking开始阶段进行 snapshot(marked all reacheable mark start),但是cocurrent的时候并发修改可能造成对象遗漏标记