## 内存结构

图

### 内存分配

1. 堆上分配

   大多数情况在eden上分配，偶尔会直接在old上分配

   细节决定gc的实现  

2. 栈上分配。

   原子类型的局部变量

### 内存回收

- gc要做的事将呢些dead的对象所占用的内存回收掉
  - hotspot认为没有引用的对象时dead的
  - hotspot将引用分为四种：Strong、Soft、Weak、Phantom
    - Strong即默认通过Object o = new Object()这种方式赋值的引用
    - Soft、Weak、Phantom这三种则都是继承Reference  
- 在full gc 时会对Reference类型的引用进行特殊处理
  - Soft:内存不够时一定会被gc、长期不用也会被gc
  - Weak:一定会被gc,当被mark为dead，会在ReferenceQueue中通知
  - Phantom:本来就没引用，当从jam heap中释放时会通知   

### 垃圾收集算法

图

### GC的时机

- 在分代模型的基础上，gc从时机上分为两种：scavenge gc和full gc
- scavenge gc(minor gc)
  - 触发时机：新对象生成时，eden空间满了
  - 理论上eden区大叔叔对象会在scaveng gc回收，复制算法的执行效率会很高，scavenge gc时间比较短
- full gc
  - 对整个jvm进行整理，包括young、odl和perm
  - 主要触发时机：1old满了；2perm满了；3 System.gc()
  - 效率很低，尽量减少full gc