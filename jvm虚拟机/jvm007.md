## JVM常见GC算法

标记-清除算法（Mark-Sweep)  

标记-整理算法（Mark-Compact）  

复制算法（Copying）  

分代算法（Generational）  

### 标记-清除算法

- 算法分为标记和清除两个阶段，首先编辑出所有需要回收的对象，然后回收所有需要回收的对象
- 缺点：
  1. 效率问题，标记和清理两个过程效率都不高
  2. 空间问题，编辑清理之后会产生大量不连续的内存碎片，空间碎片太多可能会导致后续使用中无法找到足够的连续内存而提前触发另一次的垃圾搜集动作

- 效率不高,需要扫描所有对象。堆越大，GC越慢
- 存在内存碎片问题。GC次数越多，碎片越严重

![image-20200103185030942](image/image-20200103185030942.png)

![image-20200103185050821](image/image-20200103185050821.png)

![image-20200103185103183](image/image-20200103185103183.png)

![image-20200103185125636](image/image-20200103185125636.png)

### 标记-整理算法

- 标记过程仍然一样，但是后续步骤不是进行直接清理，而是令所有存活的对象一端移动，然后直接清理掉这段边界以外的内存。

- 没有内存碎片

- 比Mark-Sweep耗费更多的时间进行compact

  ![image-20200103184513071](image/image-20200103184513071.png)

### 复制搜集算法

- 将可用内存划分为两块，每次只使用其中的一块，当半区内存用完了，仅将还存活的对象复制到另外一块上面，然后就把原来整块内存空间一次性清理掉
- 这样使得每次内存回收都是对整个半区的回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按殊勋分配内存就可以了，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，代价高昂
- 现在的商业虚拟集中都是用了这一种手机算法来回收新生代
- 将内存分为一块较大的eden空间和2块较少的survivor空间，每次使用eden和其中一块survivor,当回收时将eden和survivor还存活的对象一次拷贝到另外一块survivor空间上，然后清理掉eden和用过的survivor
- oracel hotspot虚拟机默认eden和survivor的大小比例是8：1，也就是每次只有10%的内次是浪费的
- 赋值收集算法在对象存活率搞的时候，效率有所下降
- 如果不想浪费50%的空间，就需要有额外的空间进行分配担保用于应付半区内村中所有对象都100%存活的极端情况，所以再老年代一般不能直接选用这种算法

![image-20200103174225100](image/image-20200103174225100.png)

![image-20200103174309844](image/image-20200103174309844.png)

![image-20200103174328884](image/image-20200103174328884.png)

![image-20200103174457099](image/image-20200103174457099.png)

![image-20200103174520917](image/image-20200103174520917.png)

总结：

1. 只需要扫描存活的的对象，效率更高
2. 不会产生碎片
3. 需要浪费额外的内存作为复制区
4. 复制算法非常适合声明周期比较短的对象，因为每次GC总能回收大部分的对象，复制的开销比价小
5. 根据IBM的专门研究，98%的java对象只会存活1个GC周期，对这些对象很适合用复制算法。而且不用1：1的划分工作去和复制区的算法

### 分代算法