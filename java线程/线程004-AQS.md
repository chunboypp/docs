AQS即类AbstractQueuedSynchronizer。AQS是一个提供阻塞和同步实现的框架，底层依赖于一个先进先出的等待队列。使用此类作为同步，需要重写以下方法。

tryAcquire

tryRelease

tryAcquireShared

tryReleaseShared

isHeldExclusively

获取原子状态通过getState，设置原子状态通过setState 或者compareAndSetState

同步器的设计是基于模板方式模式。继承者只需要实现指定的方法。

AQS底层是一个先进先出的双向非循环队列，队列中的节点定义类为

```java
static final class Node{
     	/**
         * 共享状态的节点。标识当前是共享模式
         */
        static final Node SHARED = new Node();
        /**
         * 标识当前是独占模式
         */
        static final Node EXCLUSIVE = null;
         /**
         * 节点在同步队列中等待超时或者被中断，需要从同步队列中取消等待，节点进入该状态不会再变化
         */
        static final int CANCELLED =  1;
        /** waitStatus value to indicate successor's thread needs unparking */
        static final int SIGNAL    = -1;
        /** waitStatus value to indicate thread is waiting on condition */
        static final int CONDITION = -2;
        /**
         * waitStatus value to indicate the next acquireShared should
         * unconditionally propagate
         */
        static final int PROPAGATE = -3;
        /**
         * 当前节点的状态。CANCELLED SIGNAL CONDITION PROPAGATE 初始化默认是0
         */
        volatile int waitStatus;
        /**
         *当前节点的前一个节点
         */
        volatile Node prev;
        /**
         * 当前节点的下一个节点
         */
        volatile Node next;
        /**
         * 当前节点持有的线程
         */
        volatile Thread thread;

        /**
         * 记录当前节点是 独享还是共享模式
         */
        Node nextWaiter;

}
```

AQS中的关键属性

```java
 	/**
     *头节点
     */
    private transient volatile Node head;
    /**
     * 尾节点
     */
    private transient volatile Node tail;
    /**
     *记录同步状态
     */
    private volatile long state;
```

## 独占式

### 获取锁

```java
 	/**
     *这里的tryAcquire 由定义锁的类进行实现。如果tryAcquire 失败且acquireQueued也失败,
     则进行中断操作
     */
    public final void acquire(long arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    

```

#### addWaiter(Node.EXCLUSIVE)方法调用分析

```java

/**
  构建node节点
  如果尾节点不为null,则通过cas方法设置当前的构建节点为尾节点
  如果尾节点为null，执行enq方法
  */
  private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        enq(node);
        return node;
    }
```

```java
/**
如果尾节点为null,则设置node为head节点。同时把head赋值给tail尾节点。
否则设置当前节点为尾节点。因为并发情况下，很可能头节点被别的线程设置了
**/
private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) { // Must initialize
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
```

#### acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) 方法调用分析

