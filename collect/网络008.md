传输层协议：tcp udp

tcp协议复杂，但是传输可靠

udp协议简单，但是传输不可靠

## udp协议

Udp（user datagram protocol）（ best effort）协议是不可靠传输，在ip的基础上增加了端口。通过端口使不同的进程进行通信

Udp协议晚于tcp协议。早期的数据传输都是基于tcp协议。ip协议功能和tcp协议功能相对独立，对于有些简单通信，best effort方式即可，tcp连接过多，网络负担重，udp相对简单，可快速处理简单通信。udp可看作ip协议在传输层的傀儡

udp协议异常简单，实际上只是起到了一个桥梁的作用

### udp协议头部

![1562591230308](../image/1562591230308.png)

source port 发出端口

destination port 目的端口

length整个udp包的长度

checksum 和ip协议的head cheksum算法类似。不同的是，udp的checksum所校验的序列包括了整个udp的数据包，及封装ip头部的一些信息（主要是发出ip和目的ip）,这样可以对ip端口的正确性进行校验。ipv4中checksum可以为0，可不使用checksum ,ipv6中必须使用checksum

### 端口与socket

tcp和udp本质上都是一个端口到另外一个端口的通信。端口使得ip层的数据包进行了区分（各自通信通道进行数据交互）

​		socket是操作系统提供的一个编程接口，用来代表某个网络通信。应用程序痛殴socket来调用系统内核中处理网络协议的模块，而这些模版会负责具体的网络协议的实施。屏蔽了底层协议实现细节（底层协议的包如何组装），应用程序只用关心 例如 ip地址 端口 传输信息

## tcp协议与流通信

Tcp(transportation control protocol)，事实上ip协议和tcp协议早期是同一个东西，后来被拆分为网络层和传输层。udp是ip协议在传输层的傀儡，实现数据包形式的通信，tcp实现流 形式的通信

### 流通信

ip协议和upd协议采用的是数据包的方式传送，后发出的数据可能早到，不能保证数据到达顺序。tcp协议确保数据到达的顺序与文本流顺序相符。计算机从tcp协议接口读取数据时，数据意识排列好顺序的流了。

tcp流边接受边记录，接受完后数据有序。udp有序必须全部接收完然后排序，才能有序记录下来-接收端压力比较大，当接收大文件时。

流的要点是次序，tcp也是基于ip协议的数据包传输的，超过mtu的数据包也会拆分。所以，tpc协议封装的ip包不是整个文本流，，而是tcp协议锁规定的片段（segment），tcp片段同样分头部(head)、数据（payload）（片段更多的作用是提示这不是完成的文本流）。整个文本流按顺序被分成小段，每一段被放入tcp片段的数据部分。tcp片段不超过ip接力路径上的最小mtu,避免碎片化问题（framentation），减少网络负担

文本流分段是在发送主机完成的，

### 可靠性

ip协议是不可靠的（best effort）,数据可能乱序

tcp补救的方法是，在没收到一个正确的、符合次序的片段后，就向发送方发送一个特殊的tcp片段（ACK回复），用来只会（ack,acknoledge）发送发：我已经收到呢个片段了。如果片段序列号为L,对应ack回复号是L+1,也就是接收方期待接收的下一个片段的序号

发送方等待一段时间后没有接收到ack回复，会重复发送（retransmit）之前发送的呢个片段（被判断为异常片段），直到收到对应片段的ack回复（L+1的ack）

发送方接收到L+1ack，推断出之前发送片段已正常接收，随后发送L+1片段。ack回复也可能丢失，发送方重复发送，接收方接收已经知会过的片段，推断ack回复丢失，重复发送ack回复。通过以上机制，使传输变的可靠。tcp是一种不断尝试，最终成功

### 滑窗

发送-》等待ack->发送->等待ack 的工作方式叫stop-and-wait，随实现了tcp通信可靠，但是牺牲了网络通信效率。

等待ack时间内，网络处理闲置（idle）状态。如果有一种方式，可同时发送多个片段，由于ip包传输无次序，可能乱序（out-of-order),我们可以在缓存中存放先存放乱序片段，等其它片段补充完毕，再将先到的片段缀在后面。 如果片段太乱，则会占用太久缓存。这种做法是：缓存一些不呢么乱的片段，期望在一段时间内补充上之前的片段（暂不处理，但发送对应的ack）;对于乱的比较厉害的片段，则将他们拒绝（不处理，也不发送对应的ack）











